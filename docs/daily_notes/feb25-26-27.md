### 25-26-27 Şubat

WebSocket Gateway + User Scoped Event Delivery

Bugün sistemde event üretildikten sonra ilgili kullanıcıya **real-time bildirim gönderilmesini** sağlayan WebSocket katmanı uçtan uca tamamlandı.

Ama yapılan iş sadece websocket açmak değildi. Asıl amaç:

> Event ingestion → processing → publish → doğru kullanıcıya realtime delivery

akışını production seviyesine yakın şekilde kurmaktı.

---

## Problem Tanımı

Event ingestion servisi çalışıyordu:

* Event API üzerinden oluşturuluyor
* Celery worker event’i işliyor
* Status değişiyor (`accepted → queued → processing → processed`)

Ancak sistem **backend içinde kapanıyordu**.

Kullanıcı tarafında:

* Event işlendi mi?
* Başarılı mı oldu?
* Failed mi oldu?

bilgisi realtime iletilemiyordu.

Amaç:

```
Event processed → ilgili kullanıcı WS üzerinden anında bilgilendirilsin
```

Slack / Stripe / GitHub notification mantığı.

---

## Mimari Karar

Broadcast yaklaşımı bilinçli olarak reddedildi.

Yanlış yaklaşım:

```
Redis publish → tüm websocket clientlara gönder
```

Bu:

* güvenlik problemi
* gereksiz trafik
* horizontal scale problemi

oluşturur.

Bu yüzden karar:

**User scoped publish**

---

## Kurulan Akış (End-to-End)

Sistem artık şu şekilde çalışıyor:

```
Client
   ↓
Nginx
   ↓
FastAPI WS Gateway
   ↓
Django Auth Introspection
   ↓
Redis Pub/Sub
   ↓
ConnectionManager (user routing)
   ↓
Doğru kullanıcı websocket bağlantısı
```

---

## 4. WebSocket Authentication Tasarımı

WS servisinin kendi auth mekanizması olması tercih edildi.

Sebep:

* WS gateway ayrı servis
* future microservice uyumu
* Django’ya tight coupling olmaması

Client bağlantısı:

```
ws://host/ws?token=<API_KEY>
```

Gateway davranışı:

1. Token alınır
2. Django internal endpoint çağrılır:

```
/internal/auth/introspect
```

3. API key doğrulanır
4. user_id alınır
5. Redis cache’e yazılır
6. WebSocket connection kabul edilir

Böylece:

* Django auth authority olur
* WS stateless kalır
* Auth cache sayesinde latency düşer

---

## Connection Management

Gateway içinde memory-based connection registry kuruldu:

```python
active_connections[conn_id] -> websocket
user_connections[user_id] -> conn_ids
```

Bu yapı sayesinde:

```
aynı user → birden fazla device/tab
```

desteklenmiş oldu.

Mesaj gönderimi:

```
send_to_user(user_id)
```

ile yalnızca ilgili connection’lara yapılır.

---

## 6. Event → WebSocket Publish

Celery processing tamamlandığında:

```python
payload = {
    "type": "event.update",
    "event_id": str(state.event_id),
    "status": state.status,
    "user_id": str(state.event.user_id),
}
```

Redis’e publish edilir:

```
tem:events
```

WS Gateway:

```
Redis SUBSCRIBE
```

ile dinler ve mesajı doğru kullanıcıya yönlendirir.

---

## Kritik Mimari Öğrenme — Pub/Sub Garantisi

Redis Pub/Sub:

* message queue değildir
* delivery guarantee vermez
* subscriber yoksa mesaj kaybolur

Bu bilinçli kabul edildi çünkü:

Realtime notification → transient data.

System of record:

✅ PostgreSQL
❌ WebSocket

WS sadece **live signal layer**.

---

## En Büyük Sorun 403 / 400 Debug Süreci

WebSocket sürekli 403 dönüyordu.

Sebep başlangıçta:

* auth hatası
* header gitmemesi
* nginx websocket upgrade
* docker network

olarak düşünüldü.

Gerçek sebep:

```
Django ALLOWED_HOSTS rejection
```

Nginx internal request’i şu host ile forward ediyordu:

```
Host: tem_nginx_gateway
```

Django request’i middleware seviyesinde reddettiği için:

* view log oluşmadı
* JSON hata dönmedi
* HTML 400 döndü

Çözüm:

```nginx
proxy_set_header Host localhost;
```

Internal servis çağrıları normalize edildi.

Bu aşama reverse proxy → application trust boundary konusunda önemli öğrenim sağlandı.

---

## Güvenlik Katmanı

Elde edilen yapı:

* WS doğrudan Django’ya erişmez
* Auth merkezi Django’dur
* Gateway cache kullanır
* Internal endpoint dışarı kapalıdır
* User isolation sağlanır

Test:

✅ user1 bağlandı
✅ user2 bağlandı
✅ user1 event oluşturdu
✅ sadece user1 mesaj aldı

Mimari doğrulandı.

---

## Sistem Davranışı (Şu An)

Artık sistem:

* Event ingest eder
* Worker işler
* Status değiştirir
* Redis publish eder
* WS gateway yakalar
* Doğru kullanıcıya realtime iletir

---

Bugünlerde yapılan iş:

* websocket yazmak değil
* realtime messaging kurmak değil

Şu problemi çözmekti:

> Distributed sistemde user-scoped realtime event delivery nasıl yapılır?

Bu aşamada:

* service boundary
* internal auth delegation
* proxy trust
* realtime routing
* pub/sub tradeoff

konuları pratik olarak deneyimlendi.

---

## Sonuç

Event ingestion servisi artık yalnızca veri kabul eden API değil:

✅ realtime feedback üreten
✅ user aware
✅ distributed notification capable
bir servis haline geldi.
